var e=Object.defineProperty,t=Object.prototype.hasOwnProperty,n=Object.getOwnPropertySymbols,a=Object.prototype.propertyIsEnumerable,o=(t,n,a)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[n]=a,i=(e,i)=>{for(var s in i||(i={}))t.call(i,s)&&o(e,s,i[s]);if(n)for(var s of n(i))a.call(i,s)&&o(e,s,i[s]);return e};import{c as s}from"./clientRender.4d8779ba.js";const l={};function r(e){var{components:o}=e,r=((e,o)=>{var i={};for(var s in e)t.call(e,s)&&o.indexOf(s)<0&&(i[s]=e[s]);if(null!=e&&n)for(var s of n(e))o.indexOf(s)<0&&a.call(e,s)&&(i[s]=e[s]);return i})(e,["components"]);return s("wrapper",i(i(i({},l),r),{components:o,mdxType:"MDXLayout"}),s("h1",null,"Example: develop a component library"),s("p",null,'This is an example of using "Advanced Filesystem Routing" inside a component library project.'),s("p",null,"Suppose you are developing a React component library. Your project have file structure like this:"),s("pre",null,s("code",i({parentName:"pre"},{className:"language-text"}),"src\n├── Button\n│   ├── demos\n│   │   ├── demo1.tsx\n│   │   └── demo2.tsx\n│   ├── index.tsx\n│   ├── style.module.css\n│   └── README.md\n├── Card\n│   ├── demos\n│   │   ├── demo1.tsx\n│   │   └── demo2.tsx\n│   ├── index.tsx\n│   ├── style.module.css\n│   └── README.md\n└── index.ts\n")),s("p",null,"You want to use vite as your local demo development environment (because it is blazingly fast). ",s("strong",{parentName:"p"},"How to collect all components and all demos from this project?"),' The file structure doesn\'t follow our "Basic Filesystem Routing Convention".'),s("p",null,"The answer: implement your own filesystem routing convention!"),s("pre",null,s("code",i({parentName:"pre"},{className:"language-ts"}),"// vite.config.ts\nimport type { UserConfig } from 'vite'\nimport * as path from 'path'\nimport reactRefresh from '@vitejs/plugin-react-refresh'\nimport mdx from 'vite-plugin-mdx'\nimport pages, { DefaultPageStrategy } from 'vite-plugin-react-pages'\n\nmodule.exports = {\n  plugins: [\n    reactRefresh(),\n    mdx(),\n    pages({\n      pagesDir: path.join(__dirname, 'pages'),\n      pageStrategy: new DefaultPageStrategy({\n        extraFindPages: async (pagesDir, helpers) => {\n          const demosBasePath = path.join(__dirname, 'src')\n          // find all component demos\n          helpers.watchFiles(\n            demosBasePath,\n            '*/demos/**/*.{[tj]sx,md?(x)}',\n            async function fileHandler(file, api) {\n              const { relative, path: absolute } = file\n              const match = relative.match(/(.*)\\/demos\\/(.*)\\.([tj]sx|mdx?)$/)\n              if (!match) throw new Error('unexpected file: ' + absolute)\n              const [_, componentName, demoPath] = match\n              const pageId = `/${componentName}`\n              const runtimeDataPaths = api.getRuntimeData(pageId)\n              runtimeDataPaths[demoPath] = absolute\n              const staticData = api.getStaticData(pageId)\n              staticData[demoPath] = await helpers.extractStaticData(file)\n              if (!staticData.title)\n                staticData.title = `${componentName} Title`\n            }\n          )\n\n          // find all component README\n          helpers.watchFiles(\n            demosBasePath,\n            '*/README.md?(x)',\n            async function fileHandler(file, api) {\n              const { relative, path: absolute } = file\n              const match = relative.match(/(.*)\\/README\\.mdx?$/)\n              if (!match) throw new Error('unexpected file: ' + absolute)\n              const [_, componentName] = match\n              const pageId = `/${componentName}`\n              const runtimeDataPaths = api.getRuntimeData(pageId)\n              runtimeDataPaths['README'] = absolute\n              const staticData = api.getStaticData(pageId)\n              staticData['README'] = await helpers.extractStaticData(file)\n              // make sure the title data is bound to this file\n              staticData.title = undefined\n              staticData.title =\n                staticData['README'].title ?? `${componentName} Title`\n            }\n          )\n        },\n      }),\n    }),\n  ],\n  resolve: {\n    alias: {\n      'my-lib': '/src',\n    },\n  },\n} as UserConfig\n")),s("p",null,"We use ",s("inlineCode",{parentName:"p"},"api.getRuntimeData(pageId)")," and ",s("inlineCode",{parentName:"p"},"api.getStaticData(pageId)")," inside fileHandlers to get the pageData object. We can mutate the data object, and vite-pages will update its pages accordingly."),s("p",null,"Checkout the complete example in ",s("a",i({parentName:"p"},{href:"https://github.com/vitejs/vite-plugin-react-pages/blob/master/packages/playground/custom-find-pages"}),"the custom-find-pages fixture"),".\nOr you can ",s("strong",{parentName:"p"},"initialize such a project in one command"),": ",s("inlineCode",{parentName:"p"},"npm init vite-pages library-demo --template lib")),s("h2",null,"Monorepo"),s("p",null,"In some cases, we want to publish each component in their own package."),s("blockquote",null,s("p",{parentName:"blockquote"},"Monorepo has more advantages when components are complex and tend to evolve independently. If we use a single package to publish all these components like the above example, all components share a version number. If we need to introduce a breaking change in a component, we have to bump the major version of the whole package. But with the monorepo we only need to bump the major version of that sub-package. Users will be more confident to upgrade.")),s("p",null,"In that case, we create a seperate package to run vite-pages, collecting all components and their demos. The project setup will look like this:"),s("pre",null,s("code",i({parentName:"pre"},{className:"language-text"}),"packages\n├── Button\n│   ├── demos\n│   │   ├── demo1.tsx\n│   │   └── demo2.tsx\n│   ├── src\n│   │   ├── index.tsx\n│   │   └── style.module.css\n│   ├── package.json\n│   └── README.md\n├── Card\n│   ├── demos\n│   │   ├── demo1.tsx\n│   │   └── demo2.tsx\n│   ├── src\n│   │   ├── index.tsx\n│   │   └── style.module.css\n│   ├── package.json\n│   └── README.md\n├── demos\n│   ├── pages\n│   │   ├── index$.tsx\n│   │   └── _theme.tsx\n│   ├── index.html\n│   ├── package.json\n│   └── vite.config.ts\n└── package.json\n")),s("p",null,"Checkout the complete example in ",s("a",i({parentName:"p"},{href:"https://github.com/vitejs/vite-plugin-react-pages/tree/master/packages/playground/lib-monorepo"}),"the lib-monorepo fixture"),".\nOr you can ",s("strong",{parentName:"p"},"initialize such a project in one command"),": ",s("inlineCode",{parentName:"p"},"npm init vite-pages library-monorepo-demo --template lib-monorepo"),"."))}r.isMDXComponent=!0;var p=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",default:r});const m={};m.main=p;export default m;
